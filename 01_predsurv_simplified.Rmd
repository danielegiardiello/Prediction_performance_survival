---
title: "Performance assessment of survival prediction models - simplified code"
subtitle: "Simplified code when individual data of development and validation set are both available"
always_allow_html: true
output:
  html_document:
  # github_document:
    toc: true
    toc_depth: 4
  keep_text: true
  pandoc_args: --webtex
---

```{r setup, include=FALSE}
# Knitr options
knitr::opts_chunk$set(
  fig.retina = 3,
  fig.path = "imgs/01_predsurv_simplified/"
)
```

## Goals
In this document, we assume that individual data of the development and validation set are both available. This file illustrates in a simplified way how to develop a survival prediction model and how to assess the corresponding prediction performance using internal and external validation.

The goals are:   
1. To develop a risk prediction model with a time-to-event outcome;  
2. To assess the prediction performance of a model with a time-to-event outcome;  
3. To assess the potential clinical utility of a risk prediction model with time-to-event outcome;  


### Set up - load packages and import data
Please run the following code to set up the data used in the following document.
We following libraries are needed to achieve the following goals, if you have not them installed, please use
install.packages('') (e.g. install.packages('survival')) or use the user-friendly approach if you are using RStudio.

```{r, wdlib, message=FALSE,warning=FALSE}

# Use pacman to check whether packages are installed, if not load
if (!require("pacman")) install.packages("pacman")
library(pacman)

pacman::p_load(
  survival,
  rms,
  pec,
  riskRegression,
  timeROC
)

options(show.signif.stars = FALSE)  # display statistical intelligence
palette("Okabe-Ito")  # color-blind friendly  (needs R 4.0)

# source("brier.R")    #  my own check on Brier scores
# COMMENT: Terry should sent it

# Development data
# Recurrence free survival (RFS) is the time until the earlier of
#  recurrence or death
rotterdam$ryear <- rotterdam$rtime/365.25  # time in years
rotterdam$rfs <- with(rotterdam, pmax(recur, death))

# variables used in the analysis
pgr99 <- quantile(rotterdam$pgr, .99) # there is a large outlier of 5000
rotterdam$pgr2 <- pmin(rotterdam$pgr, pgr99) # Winsorized value
rotterdam$csize <- rotterdam$size           # categorized size
rotterdam$cnode <- cut(rotterdam$nodes, c(-1,0, 3, 50),
                       c("0", "1-3", ">3"))   # categorized node

# Save in the data the restricted cubic spline term using Hmisc::rcspline.eval() package
rcs3_pgr <- rcspline.eval(rotterdam$pgr2, knots = c(0, 41, 486))
attr(rcs3_pgr, "dim") <- NULL
attr(rcs3_pgr, "knots") <- NULL
rotterdam$pgr3 <- rcs3_pgr

# Validation data
names(gbsg)
gbsg$ryear <- gbsg$rfstime/365.25
gbsg$rfs   <- gbsg$status           # the GBSG data contains RFS
gbsg$cnode <- cut(gbsg$nodes, c(-1,0, 3, 50),
                       c("0", "1-3", ">3"))   # categorized node
gbsg$csize <- cut(gbsg$size,  c(-1, 20, 50, 500), #categorized size
                  c("<=20", "20-50", ">50"))
gbsg$pgr2 <- pmin(gbsg$pgr, pgr99) # Winsorized value


# Restricted cubic spline for PGR
rcs3_pgr <- rcspline.eval(gbsg$pgr2, knots = c(0, 41, 486))
attr(rcs3_pgr, "dim") <- NULL
attr(rcs3_pgr, "knots") <- NULL
gbsg$pgr3 <- rcs3_pgr


# Much of the analysis will focus on the first 5 years: create
#  data sets that are censored at 5
temp <- survSplit(Surv(ryear, rfs) ~ ., data = rotterdam, cut=5,
                  episode="epoch")
rott5 <- subset(temp, epoch==1)  # only the first 5 years
temp <- survSplit(Surv(ryear, rfs) ~ ., data = gbsg, cut=5,
                  episode ="epoch")
gbsg5 <- subset(temp, epoch==1)

# Relevel
rott5$cnode <- relevel(rotterdam$cnode, "1-3")
gbsg5$cnode <- relevel(gbsg$cnode, "1-3")
```

We loaded the development (rotterdam) and the validation data (gbsg) from survival package.
The Rotterdam breast cancer data was used to predict the risk of recurrence or death using size, stage and tumor size as predictors. These three predictors were used in the Nottingham Prognostic Index, one of the most popular index to determine prognosis following surgery of breast cancer.  
The Germany Breast Cancer Study Group data was used as an external validation of the model developed in the Rotterdam breast cancer data. The prediction model will be then extended using the progesterone (PGR) marker measured at primary surgery.  
The improvement in prediction performance will be evaluated internally in the Rotterdam data (development data) and in German Breast Cancer Study data (validation data).  


## Goal 1 - Develop a risk prediction model with a time to event outcome
Prediction models are useful to provide the estimated probability of a specific outcome using personal information.
In many studies, especially in medicine, the main outcome under assessment is the time to an event of interest defined generally as survival time. Prognostic models for survival end points, such as recurrence or progression of disease, need to account for drop out during follow-up. Patients who have not experienced the event of interest are censored observations. Cox regression analysis is the most popular statistical model to deal with such data in oncology and other medical research.  

### 1.1 Preliminary investigation - survival and censoring curves in the development and validation data
First, we draw the survival and the censoring curves of the development and validation data
```{r, surv, fig.align='center'}

# Libraries needed
if (!require("pacman")) install.packages("pacman")
library(pacman)
pacman::p_load(survival)

# Development set
sfit1 <- survfit(Surv(ryear, rfs == 1) ~ 1, data = rotterdam) # survival
sfit2 <- survfit(Surv(ryear, rfs == 0) ~ 1, data = rotterdam) # censoring

par(xaxs = "i", yaxs = "i", las = 1)
plot(sfit1, conf.int = FALSE, lwd = 2, xlab = "Years", bty = "n")
lines(sfit2, conf.int = FALSE, col = 2, lwd = 2)
legend(11, .9, c("Death", "Censoring"), col = 1:2, lwd = 2, bty = "n")
title("Development set")

# Validation set
sfit3 <- survfit(Surv(ryear, rfs == 1) ~ 1, data = gbsg) # survival
sfit4 <- survfit(Surv(ryear, rfs == 0) ~ 1, data = gbsg) # censoring

par(xaxs = "i", yaxs = "i", las = 1)
plot(sfit3, conf.int = FALSE, lwd = 2, xlab = "Years", bty = "n", xlim = c(0, 8))
lines(sfit4, conf.int = FALSE, col = 2, lwd = 2)
legend("bottomleft", c("Death", "Censoring"), col = 1:2, lwd = 2, bty = "n")
title("Validation set")
```
A number of 2982 patients were included to develop the risk prediction model for survival with a median follow-up of 9.25 years.
The median survival in the development data was 8 years with the corresponding 95% confidence intervals (CIs) of 7 and 9 years.
The 5-year survival was 56% (95% CI: 54-58%). 
A number of 686 patients were selected to externally validate the risk prediction model.The median survival in the validation data was 4.5 years and the 5-year survival was 49% (95% CI: 45-54%).


### 1.2 Secondary investigation - check non linearity of continuous predictors
The potential non-linear relation between continuous predictors (i.e. progesterone level) and the outcome should be investigated before developing a risk prediction model. Non-linearity of continuous predictors can be checked using splines.  
Physically, a spline is a flexible wood or metal strip, which is passed through a set of fixed points (knots) in order to approximate a curve. The most common computational approximation to this is a cubic smoothing spline which is cubic between the knot points, and constrained to be linear beyond the two end knots. Other splines like natural splines, B-splines can be implemented. The coefficients may be completely different among different type of splines but the user should not be worried about which one to use since the predicted survival/risk will be fairly similar.
For the restricted cubic spline using rms::rcs() R package::function(), the position of the knots are defined at 10<sup>th</sup>,50<sup>th</sup> and 90<sup>th</sup> quantile of the continuous predictor distribution. For more details see Frank Harrell's book 'Regression Model Strategies' on page 27 (second edition).  
The user can specify the positions of the knots instead of using the default calculation of the knots proposed in the book of Frank Harrell.
To deal with very large influential value, we winzorize progesterone level to the 90<sup>th</sup>  percentile.

```{r,ff, warning=FALSE, fig.align='center'}
# Libraries needed
if (!require("pacman")) install.packages("pacman")
library(pacman)
pacman::p_load(survival,
               Hmisc)

pfit <-  coxph(Surv(ryear, rfs) ~ rcs(pgr2, knots=c(0, 41, 486)), rotterdam)
par(las = 1, xaxs = "i", yaxs = "i")
termplot(pfit, se=TRUE, col.term=1, col.se=1,
    xlab="PGR", ylab="Linear predictor", bty = "n")
legend(350, .25, c("rcs, knots at 0, 41, 486)"),
       col=1, lwd=1, bty='n')

# The restricted cubic spline were saved previously: see R code above.
```

### 1.3 Model development - first check - the proportional hazard (PH) assumption
We now examine the fits in a more careful way by checking the proportionality of the hazards of the Cox regression model.
Firstly, we fit the first prediction model in the development data using size, node, grade. Then, we check the PH assumption.

```{r,ph, message=FALSE, warning=FALSE,fig.align='center'} 
# Libraries needed
if (!require("pacman")) install.packages("pacman")
library(pacman)
pacman::p_load(survival)

# Fit model in the development data
fit1_cox <- coxph(Surv(ryear, rfs) ~ csize + cnode + grade, 
                  data = rotterdam, x = T, y = T)

# Test the proportional hazard assumption
options(scipen = 6)
zp1 <- cox.zph(fit1_cox, transform = "identity")
zp1$table # table output

# Proportional hazard assumption visualization
oldpar <- par(mfrow = c(2, 2), mar = c(5, 5, 1, 1))
for (i in 1:3) {
  plot(zp1[i], resid = F)
  abline(0, 0, lty = 3)
}
par(oldpar)
```

The statistical tests showed strong evidence of non-proportionality. Since the number of death is large the formal tests are quite sensitive, however, and it was important to also examine the graphs. These showed an estimated coefficient as a function of time. 

#### 1.3.1  Model development - addressing the proportional hazard (PH) assumption
As a further follow-up we will divide the data into 3 epochs of 0-5, 5-10, and 10+ years, fitting a separate model to each.

```{r, epoch,warning=FALSE}
# Libraries needed
if (!require("pacman")) install.packages("pacman")
library(pacman)
pacman::p_load(survival)

# Development
edata <- survSplit(Surv(ryear, rfs) ~ .,
  data = rotterdam, cut = c(5, 10),
  episode = "epoch"
)

# First period (0-5] years
efit1 <- coxph(Surv(ryear, rfs) ~ csize + cnode + grade,
  data = edata[edata$epoch == 1, ], x = T, y = T
)
# Second period (5-10] years
efit2 <- coxph(Surv(ryear, rfs) ~ csize + cnode + grade,
  data = edata[edata$epoch == 2, ], x = T, y = T
  )
# Third period (> 10 years)
efit3 <- coxph(Surv(ryear, rfs) ~ csize + cnode + grade,
  data = edata[edata$epoch == 3, ], x = T, y = T
)

# Results
res_efit <- round(rbind(e1 = coef(efit1), 
                        e2 = coef(efit2), 
                        e3 = coef(efit3)), 2)
rownames(res_efit) <- c("Epoch 1: 0-5 years", 
                        "Epoch 2: 5-10 years", 
                        "Epoch 3: >10 years")

res_efit

# Number of events per period
tt1 <- table(edata$epoch, edata$rfs, dnn = c("Epoch", "Status"))
rownames(tt1) <- c("Epoch 1: 0-5 years", "Epoch 2: 5-10 years", "Epoch 3: >10 years")
colnames(tt1) <- c("Censored", "Event")
tt1
```

A drastic change in the size coefficients across all epochs is apparent,
along with a major reduction in the nodes coefficient in epoch 3. As an ameleoration of this we will refit the model using only the first epoch, which includes most of the recurrences and deaths.  
We applied the administrative censoring at 5 years in the development data and we assessed the prediction performance of the prognostic model at 5 years. The hazards in the development data seem not totally proportional within 5 years but minor deviation of proportionality were considered acceptable. 

### 1.4 Model development - fit the risk prediction models
We develop the risk prediction model in the development data considering the first 5-year follow-up to minimize the violation of proportional hazard including size, node and grade. The second model also includes the progesterone level modeled using a 3-knot restricted cubic spline.  
We also administratively censored the validation data at 5 years.

```{r, model_development, fig.align='center'}
# Libraries needed
if (!require("pacman")) install.packages("pacman")
pacman::p_load(survival,
              Hmisc,
              pec)


# Fit the model without PGR
efit1 <- coxph(Surv(ryear, rfs) ~ csize + cnode + grade,
  data = rott5, x = T, y = T)
efit1

# Fit the model with PGR
efit1b <- coxph(Surv(ryear, rfs) ~ csize + cnode + grade + pgr2 + pgr3,
  data = rott5, x = T, y = T)
efit1b

rott5$lp <- predict(efit1) # linear predictor
rott5$predsurv5 <- predictSurvProb(efit1, newdata = rott5, times = 5) # predicted survival
rott5$lp_1b <- predict(efit1b)
rott5$predsurv5_1b <- predictSurvProb(efit1b, newdata = rott5, times = 5)
```

The coefficients of the models indicated that higher size, higher number of positive lymph nodes and higher grade is more associate with poorer prognosis. The association of the progesterone biomarker and the outcome is non-linear as investigated previously.


## Goal 2 - Assessing performance in survival prediction models
The performance of a risk prediction models may be evaluated through:  
  
  + discrimination:  the ability of the model to identify patients with and without the outcome and it requires the coefficients (or the log of the hazard ratios) of the developed risk prediction model to be evaluated.   

+ calibration: the agreement between observed and predicted probabilities. It requires the baseline (cumulative) hazard or survival.   

+ overall performance measures: as a combination of discrimination and calibration and/or as a measure of the explained variation;  

Unfortunately, a few publications report the complete baseline (cumulative) hazard or survival or even the baseline (cumulative) hazard or survival at fixed time horizon _t_.
If we had both individual data of the development and validation, a complete assessment of discrimination and calibration would be possible. We could evaluate the prediction performance of a risk prediction model at a fixed time horizon(s) _t_ and for the complete follow-up time.
In risk prediction, physicians typically focus on one or more clinically relevant time horizons to inform subjects about their risk. For this reasons, according to information available, different levels of validation assessment are possible.
Here we aim to assess the prediction performance of a risk prediction model with time-to-event outcome in case all individual data are available and in case of only the model equation of a fixed time horizon (i.e. at 5 years) is provided including the baseline survival.

### 2.1 Overall performance measures
We calculate the Brier Score and the Index of Prediction Accuracy (IPA, the scaled Brier) as a overall performance measure.  

We calculate the overall performance measures: Brier score, Scaled Brier (IPA) and the corresponding confidence intervals.

```{r, overall, warning=FALSE}
# COMMENTS:
# IPA 1 - Brier model \ Brier null
# COMMENT: Terry: riskRegression() does not calculate exactly Brier score
# (tied censoring and survival issue)
# COMMENT: Terry will send or publish in survival package survival::brier() function

######
# Libraries needed
if (!require("pacman")) install.packages("pacman")
library(pacman)
pacman::p_load(survival,
               Hmisc,
               pec)


# Fit the model without PGR
efit1 <- coxph(Surv(ryear, rfs) ~ csize + cnode + grade,
  data = rott5, x = T, y = T)

# Fit the model with PGR
efit1b <- coxph(Surv(ryear, rfs) ~ csize + cnode + grade + pgr2 + pgr3,
  data = rott5, x = T, y = T)


# Bootstrap
rboot <- list()
vboot <- list()
B <- 10  # Number of bootstrap samples, please increase if you neeed
set.seed(2021)
for (j in 1:B) {
rboot[[j]] <- rott5[sample(nrow(rott5), 
                           size = nrow(rott5), 
                           replace = TRUE),]

vboot[[j]] <- gbsg5[sample(nrow(gbsg5), 
                           size = nrow(gbsg5), 
                           replace = TRUE),]
}


# Brier Score and IPA in the development set (model without PGR)
# COMMENT: dynpred::pecox() does not allow to assess Brier
# using external data. I tried to modify dynpred::pecox() 
# but it uses dynpred::pe() implemented in C so it is not possible. Do you have suggestions? # Should we get in touch with Hein Putter since he is the creator of dynpred?

# COMMENT: I will wait for brier function created by Terry
score_rdata1 <-
  Score(list("Cox development" = efit1),
    formula = Surv(ryear, rfs) ~ 1, data = rott5, conf.int = TRUE, times = 4.95,
    cens.model = "km", metrics = "brier",
    summary = "ipa"
  )

# Brier Score and IPA in the development set (model with PGR)
score_rdata1b <-
  Score(list("Cox development" = efit1b),
    formula = Surv(ryear, rfs) ~ 1, data = rott5, conf.int = TRUE, times = 4.95,
    cens.model = "km", metrics = "brier",
    summary = "ipa"
  )

# Brier Score and IPA in the validation set (model without PGR)
score_vdata1 <-
  Score(list("Cox development" = efit1),
    formula = Surv(ryear, rfs) ~ 1, data = gbsg5, conf.int = TRUE, times = 4.95,
    cens.model = "km", metrics = "brier",
    summary = "ipa"
  )

# Brier Score and IPA in the validation set (model with PGR)
score_vdata1b <-
  Score(list("Cox development" = efit1b),
    formula = Surv(ryear, rfs) ~ 1, data = gbsg5, conf.int = TRUE, times = 4.95,
    cens.model = "km", metrics = "brier",
    summary = "ipa"
  )


# Scaled Brier / IPA bootstrap confidence intervals
# COMMENT: computational time is too long to compute them when the number of bootstrap replications is high
B <- length(rboot)
score_rboot_1 <- c() # Bootstrap IPA development set for model without PGR
score_rboot_1b <- c() # Bootstrap IPA development set for model with PGR
score_vboot_1 <- c() # Bootstrap IPA validation set for model without PGR
score_vboot_1b <- c() # Bootstrap IPA validation set for model with PGR

for (j in 1:B) {
  score_rboot_1[j] <-  Score(list("Cox development" = efit1), 
                         formula = Surv(ryear, rfs) ~ 1,
                         data = rboot[[j]], 
                         conf.int = FALSE, 
                         times = 4.95, 
                         cens.model = "km", 
                         metrics = "brier",
                         summary = "ipa")$Brier[[1]]$IPA[2]
  
   score_rboot_1b[j] <- Score(list("Cox development" = efit1b), 
                         formula = Surv(ryear, rfs) ~ 1,
                         data = rboot[[j]], 
                         conf.int = FALSE, 
                         times = 4.95, 
                         cens.model = "km", 
                         metrics = "brier",
                         summary = "ipa")$Brier[[1]]$IPA[2]
   
    score_vboot_1[j] <-  Score(list("Cox development" = efit1), 
                         formula = Surv(ryear, rfs) ~ 1,
                         data = vboot[[j]], 
                         conf.int = FALSE, 
                         times = 4.95, 
                         cens.model = "km", 
                         metrics = "brier",
                         summary = "ipa")$Brier[[1]]$IPA[2]
  
   score_vboot_1b[j] <- Score(list("Cox development" = efit1b), 
                         formula = Surv(ryear, rfs) ~ 1,
                         data = vboot[[j]], 
                         conf.int = FALSE, 
                         times = 4.95, 
                         cens.model = "km", 
                         metrics = "brier",
                         summary = "ipa")$Brier[[1]]$IPA[2]
}

```


```{r, res_ov_ table,warning=FALSE,echo=FALSE}
# Table overall measures
alpha <- .05
k <- 2 # number of digits
res_ov <- matrix(unlist(c(
  score_rdata1$Brier$score$Brier[2], # Brier apparent validation
  score_rdata1$Brier$score[2, 6],
  score_rdata1$Brier$score[2, 7],
  score_rdata1b$Brier$score$Brier[2], # Brier apparent validation with PGR
  score_rdata1b$Brier$score[2, 6],
  score_rdata1b$Brier$score[2, 7],
  score_vdata1$Brier$score$Brier[2], # Brier external validation
  score_vdata1$Brier$score[2, 6],
  score_vdata1$Brier$score[2, 7],
  score_vdata1b$Brier$score$Brier[2], # Brier external validation with PGR
  score_vdata1b$Brier$score[2, 6],
  score_vdata1b$Brier$score[2, 7],
  score_rdata1$Brier$score$IPA[2], # IPA apparent validation
  quantile(score_rboot_1, probs = alpha / 2),
  quantile(score_rboot_1, probs = 1 - alpha / 2),
  score_rdata1b$Brier$score$IPA[2], # IPA apparent validation with PGR
  quantile(score_rboot_1b, probs = alpha / 2),
  quantile(score_rboot_1b, probs = 1 - alpha / 2),
  score_vdata1$Brier$score$IPA[2], # IPA external validation
  quantile(score_vboot_1, probs = alpha / 2),
  quantile(score_vboot_1, probs = 1 - alpha / 2),
  score_vdata1b$Brier$score$IPA[2], # IPA external validation with PGR
  quantile(score_vboot_1b, probs = alpha / 2),
  quantile(score_vboot_1b, probs = 1 - alpha / 2)
)),
nrow = 8, 
ncol = 3, 
byrow = T, 
dimnames = list(
  c("Brier - Development data - model without PGR", 
    "Scaled Brier - Development data - model without PGR",
    "Brier - Development data - model with PGR", 
    "Scaled Brier - Development data - model with PGR",
    "Brier - Validation data - model without PGR", 
    "Scaled Brier - Validation data - model without PGR",
    "Brier - Validation data - model with PGR", 
    "Scaled Brier - Validation data - model with PGR"),
  c("Estimate", "Lower .95 ", "Upper .95"))
)


res_ov <- round(res_ov, 2) # Digit
res_ov
```

As expected the overall performance measures were lower in the external validation. Including information about PGR slightly improved the overall performance.

### 2.2 Discrimination measures
Discrimination is the ability to differentiate between subjects who have the outcome and subjects who do not.
Concordance can be assessed over several different time intervals:

* the entire range of the data
* a 5 year window corresponding to our target assessment point

Clearly the last of these is most relevant.

This is easy to compute using the concordance function in the survival
package.
There is some uncertainty in the literature about the original Harrell
formulation versus Uno's suggestion to re-weight the time scale by the
factor $1/G^2(t)$ where $G$ is the censoring distribution.
There is more detailed information in the concordance vignette found in the
survival package.

We also propose to calculate Uno's time-dependent AUC at a specific time horizon _t_.  
More explanations and details are in the paper.  
The time horizon to calculate the time-dependent measures was set to 5 years.
Values close to 1 indicate good discrimination ability, while values close to 0.5 indicated poor discrimination ability.  
We used the time horizon at 4.95 and not 5 years since controls are considered patients at risk after the time horizon and we administratively censored at 5 years to minimize the violation of PH assumption (see paragraph 1.3).

```{r, concordance,warning=FALSE}
# Libraries needed
if (!require("pacman")) install.packages("pacman")
library(pacman)
pacman::p_load(survival,
               Hmisc,
               pec,
               timeROC)

# Fit the model without PGR
efit1 <- coxph(Surv(ryear, rfs) ~ csize + cnode + grade,
  data = rott5, x = T, y = T)

# Fit the model with PGR
efit1b <- coxph(Surv(ryear, rfs) ~ csize + cnode + grade + pgr2 + pgr3,
  data = rott5, x = T, y = T)


# Add linear predictor n the development set
rott5$lp <- predict(efit1) # linear predictor
rott5$lp_1b <- predict(efit1b)

# Add linear predictor in the validation set
gbsg5$lp <- predict(efit1, newdata = gbsg5)
gbsg5$lp_1b <- predict(efit1b, newdata = gbsg5)


### Harrell and Uno's concordance index 
## Development data
# Harrell's C
harrell_C_rdata <- concordance(efit1)
harrell_C_rdata1b <- concordance(efit1b)
# Uno's C
Uno_C_rdata <- concordance(efit1, timewt="n/G2")
Uno_C_rdata1b <- concordance(efit1b, timewt="n/G2")

## Validation data
# Harrell's C
harrell_C_vdata <- concordance(Surv(ryear, rfs) ~ lp, 
                               gbsg5, 
                               reverse=TRUE)
harrell_C_vdata1b <- concordance(Surv(ryear, rfs) ~ lp_1b, 
                                 gbsg5, 
                                 reverse=TRUE)
# Uno's C
Uno_C_vdata <- concordance(Surv(ryear, rfs) ~ lp, 
                           gbsg5, 
                           reverse=TRUE,
                           timewt="n/G2")

Uno_C_vdata1b <-concordance(Surv(ryear, rfs) ~ lp_1b, 
                           gbsg5, 
                           reverse=TRUE,
                           timewt="n/G2")
```


```{r, concordance_table,warning=FALSE,echo=FALSE}
temp <- c(
  harrell_C_rdata$concordance,
  harrell_C_rdata$concordance - 
    qnorm(1 - alpha/2) * sqrt(harrell_C_rdata$var),
  harrell_C_rdata$concordance + 
    qnorm(1 - alpha/2) * sqrt(harrell_C_rdata$var),
  
  
  Uno_C_rdata$concordance,
  Uno_C_rdata$concordance - 
    qnorm(1 - alpha/2) * sqrt(Uno_C_rdata$var),
  Uno_C_rdata$concordance + 
    qnorm(1 - alpha/2) * sqrt(Uno_C_rdata$var),
  
  harrell_C_rdata1b$concordance,
  harrell_C_rdata1b$concordance - 
    qnorm(1 - alpha/2) * sqrt(harrell_C_rdata1b$var),
  harrell_C_rdata1b$concordance + 
    qnorm(1 - alpha/2) * sqrt(harrell_C_rdata1b$var),
  
  Uno_C_rdata1b$concordance, 
  Uno_C_rdata1b$concordance - 
    qnorm(1 - alpha/2) * sqrt(Uno_C_rdata1b$var),
  Uno_C_rdata1b$concordance + 
    qnorm(1 - alpha/2) * sqrt(Uno_C_rdata1b$var),
  
  harrell_C_vdata$concordance,
  harrell_C_vdata$concordance - 
    qnorm(1 - alpha/2) * sqrt(harrell_C_vdata$var),
  harrell_C_vdata$concordance + 
    qnorm(1 - alpha/2) * sqrt(harrell_C_vdata$var),

  
  Uno_C_vdata$concordance,
  Uno_C_vdata$concordance - 
    qnorm(1 - alpha/2) * sqrt(Uno_C_vdata$var),
  Uno_C_vdata$concordance + 
    qnorm(1 - alpha/2) * sqrt(Uno_C_vdata$var),
  
  harrell_C_vdata1b$concordance,
  harrell_C_vdata1b$concordance - 
    qnorm(1 - alpha/2) * sqrt(harrell_C_vdata1b$var),
  harrell_C_vdata1b$concordance + 
    qnorm(1 - alpha/2) * sqrt(harrell_C_vdata1b$var),
  
  Uno_C_vdata1b$concordance, 
  Uno_C_vdata1b$concordance - 
    qnorm(1 - alpha/2) * sqrt(Uno_C_vdata1b$var),
  Uno_C_vdata1b$concordance + 
    qnorm(1 - alpha/2) * sqrt(Uno_C_vdata1b$var)
          
)
res_C  <- matrix(temp, 
                nrow = 8, 
                ncol = 3, 
                byrow = TRUE,
                dimnames = list(
  c("Harrell C - Development data - model without PGR", 
    "Uno C - Development data - model without PGR",
    "Harrell C - Development data - model with PGR", 
    "Uno C  - Development data - model with PGR",
    "Harrell C - Validation data - model without PGR", 
    "Uno C - Validation data - model without PGR",
    "Harrell C - Validation data - model with PGR", 
    "Uno C - Validation data - model with PGR"),
  
  c("Estimate", "Lower .95", "Upper .95"))
)

res_C <- round(res_C, 2) # Digit
res_C
```
COMMENT: please comment the results and differences between Harrell and Uno's concordance
index (see also the chapter of Terry's book)


```{r, AUC,warning=FALSE,echo=FALSE}
# Time-dependent AUC (in Table 3 called Uno's TD AUC at 5 years) ###
# Uno's time-dependent Area Under the Curve
# Apparent
Uno_rdata1 <-
  timeROC(
    T = rott5$ryear, delta = rott5$rfs,
    marker = predict(efit1, newdata = rott5),
    cause = 1, weighting = "marginal", times = 4.95,
    iid = TRUE
  )

# External validation
Uno_vdata1 <-
  timeROC(
    T = gbsg5$ryear, delta = gbsg5$rfs,
    marker = predict(efit1, newdata = gbsg5),
    cause = 1, weighting = "marginal", times = 4.95,
    iid = TRUE
  )

# Apparent with pgr
Uno_rdata1b <-
  timeROC(
    T = rott5$ryear, delta = rott5$rfs,
    marker = predict(efit1b, newdata = rott5),
    cause = 1, weighting = "marginal", times = 4.95,
    iid = TRUE
  )

# External validation with pgr
Uno_vdata1b <-
  timeROC(
    T = gbsg5$ryear, delta = gbsg5$rfs,
    marker = predict(efit1b, newdata = gbsg5),
    cause = 1, weighting = "marginal", times = 4.95,
    iid = TRUE
  )
# COMMENT: if you have a lot of data n > 2000, standard error computation may be really long. Please use bootstrap percentile to calculate confidence intervals.
```

```{r, AUC_table,warning=FALSE,echo=FALSE}
# Save results
alpha <- .05
k <- 2
res_discr <- matrix(c(
  Uno_rdata1$AUC["t=4.95"],
  Uno_rdata1$AUC["t=4.95"] -
    qnorm(1 - alpha / 2) * Uno_rdata1$inference$vect_sd_1["t=4.95"],
  Uno_rdata1$AUC["t=4.95"] +
    qnorm(1 - alpha / 2) * Uno_rdata1$inference$vect_sd_1["t=4.95"],
  Uno_rdata1b$AUC["t=4.95"],
  Uno_rdata1b$AUC["t=4.95"] -
    qnorm(1 - alpha / 2) * Uno_rdata1b$inference$vect_sd_1["t=4.95"],
  Uno_rdata1b$AUC["t=4.95"] +
    qnorm(1 - alpha / 2) * Uno_rdata1b$inference$vect_sd_1["t=4.95"],
  Uno_vdata1$AUC["t=4.95"],
  Uno_vdata1$AUC["t=4.95"] -
    qnorm(1 - alpha / 2) * Uno_vdata1$inference$vect_sd_1["t=4.95"],
  Uno_vdata1$AUC["t=4.95"] +
    qnorm(1 - alpha / 2) * Uno_vdata1$inference$vect_sd_1["t=4.95"],
  Uno_vdata1b$AUC["t=4.95"],
  Uno_vdata1b$AUC["t=4.95"] -
    qnorm(1 - alpha / 2) * Uno_vdata1b$inference$vect_sd_1["t=4.95"],
  Uno_vdata1b$AUC["t=4.95"] +
    qnorm(1 - alpha / 2) * Uno_vdata1b$inference$vect_sd_1["t=4.95"]
),
  nrow = 4, ncol = 3, byrow = T, 
  dimnames = list( 
    c(
      "Uno AUC - Development data - model without PGR",
      "Uno AUC - Development data - model with PGR",
      "Uno AUC - Validation data - model without PGR",
      "Uno AUC - Validation data - model with PGR"),
  
  c("Estimate", "Lower .95", "Upper .95"))
)

res_discr <- round(res_discr, k)
res_discr
```

The time-dependent AUCs at 5 years were in the external validation were between 0.70 and 0.73 showing moderate discrimination. The additional information of the PGR marker increased the discrimination by 0.03.


### 2.3 Calibration
Calibration is the agreement between observed outcomes and predicted probabilities.
For example, in survival models, a predicted survival probability at a fixed time horizon _t_ of 80% is considered reliable if it can be expected that 80 out of 100 will survive among patients received a predicted survival probability of 80%.

Calibration is measured by:

+ Observed and Expected ratio at time horizon (*t*):   
  + the number of observed event is calculated as the one minus the Kaplan-Meier curve at time *t*;
  
  + the number of expected event is calculated as the mean of the predicted risk at time *t*;
  
  + Confidence intervals are calculated using the Normal approximation of the Poisson distribution.
  

+ Calibration plot: it is a graphical representation of calibration in-the-large and calibration. It shows:
  
  + on the _x-axis_ the predicted survival (or risk) probabilities at a fixed time horizon (e.g. at 5 years);

  + on the _y-axis_ the observed survival (or risk) probabilities at a fixed time horizon (e.g. at 5 years);

  + The 45-degree line indicates the good overall calibration. 
Points below the 45-degree line indicates that the model overestimate the observed risk. 
If points are above the 45-degree line, the model underestimate the observed risk;
The observed probabilities estimated by the Kaplan-Meier curves (in case of survival) or by the complementary of the Kaplan-Meier curves (in case of risk in absence of competing risks) are represented in terms of percentiles of the predicted survival (risk) probabilities.  


Other calibration measures are proposed in the literature. More details are provided in the references at the end of the document. 

### 2.3.1 Observed Expected ratio

We calculate the observed/ expected ratio (OE) at 5 years in the development and validation data.
In the development data the OE should be (close to) 1.  

```{r, OE, fig.align='center',warning=FALSE,message=FALSE}
# Libraries needed
if (!require("pacman")) install.packages("pacman")
library(pacman)
pacman::p_load(survival,
               Hmisc)


# Fit the model without PGR
efit1 <- coxph(Surv(ryear, rfs) ~ csize + cnode + grade,
  data = rott5, x = T, y = T)

# Fit the model with PGR
efit1b <- coxph(Surv(ryear, rfs) ~ csize + cnode + grade + pgr2 + pgr3,
  data = rott5, x = T, y = T)


# Add predicted survival at 5 years in the development set
rott5$predsurv5 <- predictSurvProb(efit1, newdata = rott5, times = 5) # predicted survival
rott5$predsurv5_1b <- predictSurvProb(efit1b, newdata = rott5, times = 5)

# Add predicted survival at 5 ears in the validation set
gbsg5$predsurv5 <- predictSurvProb(efit1, newdata = gbsg5, times = 5)
gbsg5$predsurv5_1b <- predictSurvProb(efit1b, newdata = gbsg5, times = 5)

#' Calculate the O/E ratio
#'
#' @param tfup follow-up time
#' @param event variable indication event (0=no, 1=yes)
#' @param pred.risk predicted risk at time horizon
#' @param thorizon time horizon to calculate the observed/expected ratio at time t
#' @param alpha type I error (to calculate confidence intervals, default: 0.05)
#'
#' @return 
#'
#' @examples

OE.ratio.t <- function(tfup, event, pred.risk, thorizon, alpha = .05) {
  obs_t <- 1 - summary(survfit(Surv(tfup, event) ~ 1), times = thorizon)$surv
  exp_t <- mean(pred.risk, na.rm = T)

  OE <- obs_t / exp_t
  OE.lower <- OE * exp(-qnorm(1 - alpha / 2) * sqrt(1 / sum(event)))
  OE.upper <- OE * exp(+qnorm(1 - alpha / 2) * sqrt(1 / sum(event)))
  res <- c(OE, OE.lower, OE.upper)
  names(res) <- c("Estimate", "Lower .95", "Upper .95")
  return(res)
}
# O\E ratio f
OE.rdata <- round(OE.ratio.t(tfup = rotterdam$ryear,
                             event = rotterdam$rfs, 
                             pred.risk = 1 - rott5$predsurv5, 
                             thorizon = 5), 2)

OE.rdata1b <- round(OE.ratio.t(tfup =  rotterdam$ryear, 
                               event = rotterdam$rfs, 
                               pred.risk = 1 - rott5$predsurv5_1b, 
                               thorizon = 5), 2)

OE.vdata <- round(OE.ratio.t(tfup = gbsg$ryear, 
                             event = gbsg$rfs, 
                             pred.risk = 1 - gbsg5$predsurv5, 
                             thorizon = 5), 2)

OE.vdata1b <- round(OE.ratio.t(tfup = gbsg$ryear, 
                               event = gbsg$rfs, 
                               pred.risk = 1 - gbsg5$predsurv5_1b, 
                               thorizon = 5), 2)
```

```{r, OE_table,warning=FALSE,echo=FALSE}
res_OE <- matrix(c(
  OE.rdata,
  OE.rdata1b,
  OE.vdata,
  OE.vdata1b
),
nrow = 4, ncol = 3, byrow = T,
dimnames = list(
   c(
      "O/E ratio - Development data - model without PGR",
      "O/E ratioE ratio - Development data - model with PGR",
      "O/E ratio - Validation data - model without PGR",
      "O/E ratio - Validation data - model with PGR"),
  
  c("Estimate", "Lower .95", "Upper .95"))
)


res_OE <- round(res_OE, 2)
res_OE

# COMMENT: we can propose the Poisson approach instead of the above calculation
```

The models PGR tend to slightly under-predict the risk of mortality in the validation data. 

### 2.3.2 Calibration plot using restricted cubic splines
Calibration plots of the external validation data with and without PGR are calculated and shown using restricted cubic splines.  
The interpretation of the calibration plot were provided in the section 2.3 of this document, in the corresponding paper and in the literature provided in the paper and at the end of this document. More details about the method are given in the references below.

```{r, cal_rcs, fig.align='center',warning=FALSE,message=FALSE}
if (!require("pacman")) install.packages("pacman")
library(pacman)
pacman::p_load(survival,
               Hmisc,
               rms)

####################
# Calibration plot #
####################

###############################
## External data without PGR  #
###############################

# Fit model with rms::cph() since it is useful to get confidence intervals of prediction
efit1_cph <- cph(formula = Surv(ryear, rfs) ~ csize + cnode + grade, 
                 data = rott5, x = T, y = T, surv = T)
gbsg5$predmort5 <- 1 - survest(efit1_cph, newdata = gbsg5, times = 5)$surv
# gbsg5$predmort5 <- 1- predictSurvProb(efit1, newdata = gbsg5, times = 5)
gbsg5$predmort5.cll <- log(-log(1 - gbsg5$predmort5))

# Estimate
vcalibrate.efit1 <- cph(Surv(ryear, rfs) ~ rcs(predmort5.cll, 3),
  x = T, y = T,
  data = gbsg5, 
  surv = T
) 

# Create a grid of values according to the predicted risk distribution
predict.grid <- seq(quantile(gbsg5$predmort5, prob = 0.01, na.rm = TRUE), 
                    quantile(gbsg5$predmort5, prob = 0.99, na.rm = TRUE), 
                    length = 100)

predict.grid.cll <- log(-log(1 - predict.grid))
predict.grid.df <- data.frame(predict.grid)
predict.grid.cll.df <- data.frame(predict.grid.cll)
names(predict.grid.df) <- "predmort5"
names(predict.grid.cll.df) <- "predmort5.cll"

# Plot
pred.vcalibrate.efit1 <- 1 - survest(vcalibrate.efit1, 
                                     newdata = predict.grid.cll.df, 
                                     times = 5)$surv

pred.vcalibrate.efit1.upper <- 1 - survest(vcalibrate.efit1, 
                                           newdata = predict.grid.cll.df, 
                                           times = 5)$lower

pred.vcalibrate.efit1.lower <- 1 - survest(vcalibrate.efit1, 
                                           newdata = predict.grid.cll.df, 
                                           times = 5)$upper
par(xaxs = "i", yaxs = "i", las = 1)
plot(
  predict.grid, 
  pred.vcalibrate.efit1,
  type = "l", 
  lty = 1, 
  xlim = c(0, 1),
  ylim = c(0, 1), lwd = 2,
  xlab = "Predicted probability",
  ylab = "Observed probability", bty = "n"
)
lines(predict.grid, 
      pred.vcalibrate.efit1.lower, 
      type = "l", 
      lty = 2, 
      lwd = 2)
lines(predict.grid, 
      pred.vcalibrate.efit1.upper,
      type = "l", 
      lty = 2, 
      lwd = 2)
abline(0, 1, lwd = 2, lty = 2, col = "red")
title("A External data without PGR", adj = 0)
# par(new=T)
# plot(density(evdata1$predmort5),axes=F,xlab=NA,ylab=NA,
#     main="")

############################
## External data with PGR  #
############################

# Model with cph to get the confidence intervals of the prediction
efit1b_cph <- cph(formula = Surv(ryear, rfs) ~ csize + cnode + grade + pgr2 + pgr3, 
                 data = rott5, x = T, y = T, surv = T)
gbsg5$predmort5_1b <- 1 - survest(efit1b_cph, newdata = gbsg5, times = 5)$surv
gbsg5$predmort5.cll_1b <- log(-log(1 - gbsg5$predmort5_1b))

# Estimate
vcalibrate.efit1b <- cph(Surv(ryear, rfs) ~ rcs(predmort5.cll_1b, 3),
  x = T, y = T, data = gbsg5, surv = T
)

predict.grid <- seq(quantile(gbsg5$predmort5_1b, prob = 0.01, na.rm = TRUE), 
                    quantile(gbsg5$predmort5_1b, prob = 0.99, na.rm = TRUE), 
                    length = 100)

predict.grid.cll <- log(-log(1 - predict.grid))
predict.grid.df <- data.frame(predict.grid)
predict.grid.cll.df <- data.frame(predict.grid.cll)
names(predict.grid.df) <- "predmort5_1b"
names(predict.grid.cll.df) <- "predmort5.cll_1b"

# Plot
pred.vcalibrate.efit1b <- 1 - survest(vcalibrate.efit1b, 
                                      newdata = predict.grid.cll.df, 
                                      times = 5)$surv
pred.vcalibrate.efit1b.lower <- 1 - survest(vcalibrate.efit1b, 
                                            newdata = predict.grid.cll.df, 
                                            times = 5)$upper
pred.vcalibrate.efit1b.upper <- 1 - survest(vcalibrate.efit1b, 
                                            newdata = predict.grid.cll.df, 
                                            times = 5)$lower
par(xaxs = "i", yaxs = "i", las = 1)
plot(predict.grid, pred.vcalibrate.efit1b,
  type = "l", lty = 1, xlim = c(0, 1),
  ylim = c(0, 1), lwd = 2,
  xlab = "Predicted probability of recurrence at 5 years",
  ylab = "Observed probability of recurrence at 5 years", bty = "n"
)
lines(predict.grid, pred.vcalibrate.efit1b.lower, type = "l", lty = 2, lwd = 2)
lines(predict.grid, pred.vcalibrate.efit1b.upper, type = "l", lty = 2, lwd = 2)
abline(0, 1, lwd = 2, lty = 2, col = "red")
title("B External data with PGR", adj = 0)
# par(new=T)
# plot(density(evdata1$predmort5),axes=F,xlab=NA,ylab=NA,
#     main="")
```

Both plots identified good calibration although probabilities of recurrence were slightly underestimated especially for the lowest and the highest values of 
the observed probabilities of recurrence.  
The additional information of PGR improved the overall calibration, especially for the highest values, as shown in the two calibration plots above.


## Goal 3 - Clinical utility
Discrimination and calibration measures are essential to assess the prediction performance but insufficient to evaluate the potential clinical utility of a risk prediction model for decision making. When new markers are available, clinical utility assessment evaluates whether the extended model helps to improve decision making.  
Clinical utility is measured by the net benefit that includes the number of true positives and the number of false positives. For example, in time-to-event models, the true positives reflect the benefit of being event free for a given time horizon using additional interventions such as additional treatments, personalized follow-up or additional surgeries. The false positives represent the harms of unnecessary interventions.   
Generally, in medicine, clinicians accepts to treat a certain number of patients for which interventions are unnecessary to be event free for a given time horizon. So, false negatives (the harm of not being event free for a given time horizon) are more important than false positives (the harm of unnecessary interventions). Thus, net benefit is the number of true positives classifications minus the false positives classifications weighted by a factor related to the harm of not preventing the event versus unnecessary interventions. The weighting is derived from the threshold probability to death (one minus survival probability) using a defined time horizon (for example 5 years since diagnosis). For example, a threshold of 10% implies that additional interventions for 10 patients of whom one would have experience the event in 5 years if untreated is acceptable (thus treating 9 unnecessary patients). This strategy is compared with the strategies of treat all and treat none patients. If overtreatment is harmful, a higher threshold should be used.  
The net benefit is calculated as:  
  
<img src="https://render.githubusercontent.com/render/math?math=%5Chuge%7B%5Cfrac%7BTP%7D%7Bn%7D-%5Cfrac%7BFP%7D%7Bn%7D*%5Cfrac%7Bp_t%7D%7B1-p_t%7D%7D">
  
*TP*=true positive patients   
*FP*=false positive patients  
*n*=number of patients and *p*<sub>t</sub> is the risk threshold.  

For survival data *TP* and *FP* is calculated as follows:   
<img src="https://render.githubusercontent.com/render/math?math=%5CLarge%7BTP%20%3D%20%5B1-S(t)%7C%20X%3D1%5D*P(X%3D1)*n%7D">
  
<img src="https://render.githubusercontent.com/render/math?math=%5CLarge%7BFP%20%3D%20%5BS(t)%7C%20X%3D1%5D*P(X%3D1)*n%7D">
  
  where  
*S(t)* survival at time *t*  
  *X=1* where the predicted probability at time *t* is  *p*<sub>t</sub>  
  
  And the the decision curve is calculated as follows:
  
1. Choose a time horizon (in this case 5 years);
2. Specify a risk threshold which reflects the ratio between harms and benefit of an additional intervention;
3. Calculate the number of true positive and false positive given the threshold specified in (2);
4. Calculate the net benefit of the survival model;
5. Plot net benefit on the *y-axis* against the risk threshold on the *x-axis*;
6. Repeat steps 2-4 for each model consideration;
7. Repeat steps 2-4 for the strategy of assuming all patients are treated;
8. Draw a straight line parallel to the *x-axis* at y=0 representing the net benefit associated with the strategy of assuming that all patients are not treated.

Given some thresholds, the model/strategy with higher net benefit represents the one that potentially improves  clinical decision making. However, poor discrimination and calibration lead to lower net benefit.

```{r, function_stdca, message=FALSE,warning=FALSE, fig.align='center',include=FALSE}
if (!require("pacman")) install.packages("pacman")
library(pacman)
pacman::p_load(here)

# Run the function to calculate the net benefit and the elements needed to develop decision curve analysis
source(here::here("Functions/stdca.R"))
# COMMENT: please change the directory
# source("C:/Users/dgiardiello/Documents/GitHub/Prediction_performance_survival/Functions/stdca.R")
```


```{r, dca, message=FALSE,warning=FALSE, fig.align='center'}
if (!require("pacman")) install.packages("pacman")
library(pacman)
pacman::p_load(survival,
               Hmisc)

# Fit the model without PGR
efit1 <- coxph(Surv(ryear, rfs) ~ csize + cnode + grade,
  data = rott5, x = T, y = T)

# Fit the model with PGR
efit1b <- coxph(Surv(ryear, rfs) ~ csize + cnode + grade + pgr2 + pgr3,
  data = rott5, x = T, y = T)


# Add predicted survival at 5 years in the development set
rott5$predsurv5 <- predictSurvProb(efit1, newdata = rott5, times = 5) # predicted survival
rott5$predsurv5_1b <- predictSurvProb(efit1b, newdata = rott5, times = 5)

# Add predicted survival at 5 years in the validation set
gbsg5$predsurv5 <- predictSurvProb(efit1, newdata = gbsg5, times = 5)
gbsg5$predsurv5_1b <- predictSurvProb(efit1b, newdata = gbsg5, times = 5)

###########################
# Decision curve analysis #
###########################

# Development data
# Predicted probability calculation
rott5$mort5_efit1 <- 1 - rott5$predsurv5

# Extended model with PGR
# Predicted probability calculation
rott5$mort5_efit1b <- 1 - rott5$predsurv5_1b 

# Run decision curve analysis

# Development data
# Model without PGR
rott5 <- as.data.frame(rott5)
dca_rdata_1 <- stdca(
  data = rott5, outcome = "rfs", ttoutcome = "ryear",
  timepoint = 5, predictors = "mort5_efit1", xstop = 1.0,
  ymin = -0.01, graph = FALSE
)
# Model with PGR
dca_rdata_1b <- stdca(
  data = rott5, outcome = "rfs", ttoutcome = "ryear",
  timepoint = 5, predictors = "mort5_efit1b", xstop = 1.0,
  ymin = -0.01, graph = FALSE
)

# Decision curves plot
par(xaxs = "i", yaxs = "i", las = 1)
plot(dca_rdata_1$net.benefit$threshold,
  dca_rdata_1$net.benefit$mort5_efit1,
  type = "l", lwd = 2, lty = 1,
  xlab = "Threshold probability in %", ylab = "Net Benefit",
  xlim = c(0, 1), ylim = c(-0.10, 0.45), bty = "n",
  cex.lab = 1.2, cex.axis = 1
)
# legend('topright',c('Treat all','Treat none','Prediction model'),
#        lwd=c(2,2,2),lty=c(1,1,2),col=c('darkgray','black','black'),bty='n')
lines(dca_rdata_1$net.benefit$threshold, dca_rdata_1$net.benefit$none, type = "l", lwd = 2, lty = 4)
lines(dca_rdata_1$net.benefit$threshold, dca_rdata_1$net.benefit$all, type = "l", lwd = 2, col = "darkgray")
lines(dca_rdata_1b$net.benefit$threshold, dca_rdata_1b$net.benefit$mort5_efit1b, type = "l", lwd = 2, lty = 5)
legend("topright",
  c(
    "Treat All",
    "Original model",
    "Original model + PGR",
    "Treat None"
  ),
  lty = c(1, 1, 5, 4), lwd = 2, col = c("darkgray", "black", "black", "black"),
  bty = "n"
)
title("A Development data", adj = 0, cex = 1.5)


# External data
# Validation data
# Predicted probability calculation
gbsg5$mort5_model1 <- 1 - predictSurvProb(efit1, newdata = gbsg5, times = 5)

# Extended model with PGR
# Predicted probability calculation
gbsg5$mort5_model1b <- 1 - predictSurvProb(efit1b, newdata = gbsg5, times = 5)

# Run decision curve analysis

# Development data
# Model without PGR
gbsg5 <- as.data.frame(gbsg5)
dca_vdata_model1 <- stdca(
  data = gbsg5, outcome = "rfs", ttoutcome = "ryear",
  timepoint = 5, predictors = "mort5_model1", xstop = 1.0,
  ymin = -0.01, graph = FALSE
)
# Model with PGR
dca_vdata_model1b <- stdca(
  data = gbsg5, outcome = "rfs", ttoutcome = "ryear",
  timepoint = 5, predictors = "mort5_model1b", xstop = 1,
  ymin = -0.01, graph = FALSE
)

# Decision curves plot
par(xaxs = "i", yaxs = "i", las = 1)
plot(dca_vdata_model1$net.benefit$threshold,
  dca_vdata_model1$net.benefit$mort5_model1,
  type = "l", lwd = 2, lty = 1,
  xlab = "Threshold probability in %", ylab = "Net Benefit",
  xlim = c(0, 1), ylim = c(-0.10, 0.60), bty = "n",
  cex.lab = 1.2, cex.axis = 1
)
# legend('topright',c('Treat all','Treat none','Prediction model'),
#        lwd=c(2,2,2),lty=c(1,1,2),col=c('darkgray','black','black'),bty='n')
lines(dca_vdata_model1$net.benefit$threshold, dca_vdata_model1$net.benefit$none, type = "l", lwd = 2, lty = 4)
lines(dca_vdata_model1$net.benefit$threshold, dca_vdata_model1$net.benefit$all, type = "l", lwd = 2, col = "darkgray")
lines(dca_vdata_model1b$net.benefit$threshold, dca_vdata_model1b$net.benefit$mort5_model1b, type = "l", lwd = 2, lty = 5)
legend("topright",
  c(
    "Treat All",
    "Original model",
    "Original model + PGR",
    "Treat None"
  ),
  lty = c(1, 1, 5, 4), lwd = 2, col = c("darkgray", "black", "black", "black"),
  bty = "n"
)
title("B External data", adj = 0, cex = 1.5)
```

Based on previous research we used a range of thresholds from 14% to 23% for adjuvant chemotherapy. If we choose a threshold of 20% the model had a potential net benefit of 0.294 in the development data using the basic model. This means that the model would identify 29 patients per 100 who will have recurrent breast cancer or die within 5 years since diagnosis and thus adjuvant chemotherapy is potentially needed.   
The decision curve shows that the net benefit would be much larger for higher threshold values, i.e., patients accepting higher risks of recurrence compared to the treat all strategy. The same interpretation may be used in the validation data:
  choosing a threshold of 20% the basic model had a net benefit of 0.384 for the basic and the extended model.  
Moreover, potential net benefit can be defined in terms of reduction of avoidable interventions (e.g adjuvant chemotherapy per 100 patients) by:
  
<img src="https://render.githubusercontent.com/render/math?math=%5Chuge%7B%5Cfrac%7BNB_%7Bmodel%7D%20-%20NB_%7Ball%7D%7D%7B(p_t%2F%20(1-p_t))%7D*100%7D%0A">  
  
  where *NB*<sub>model</sub> is the net benefit of the prediction model, *NB*<sub>all</sub> is the net benefit of the strategy treat all and $p_{t}$ is the risk threshold.


## Reproducibility ticket

```{r repro_ticket, echo=TRUE}
sessioninfo::session_info()
```

